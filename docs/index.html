<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BLADE graph gen</title>
  <script src="parser.js"></script>
  <script src="viz.js"></script>
  <style>
    body {
      max-width: 60em;
      margin: auto;
    }

    textarea {
      width: 100%;
      height: 25em;
    }
  </style>
</head>
<body>
  Generate alpha-nodes: <input id="gen-alpha" type="checkbox">
  <br>
  Generate full def-use graph: <input id="gen-defuse" type="checkbox">
  <br>
  <textarea id="input" height=100 width=100>
    x := 0;
    while x < length(a) do
      y := a[x];
      b[y] := x + 1;
      z := b[y];
      if z < 0 then
        x:=0
      else
        y:=0
      endif
    endwhile
  </textarea><br>
  <details>
    <summary>Syntax:</summary>
    <pre>
&lt;cmd_seq&gt; ::=
    &lt;cmd&gt; ';' &lt;cmd_seq&gt;
  | &lt;cmd&gt;

&lt;cmd&gt; ::=
    'skip'
  | 'fail'
  | 'if' &lt;expr&gt; 'then' &lt;cmd_seq&gt; 'else' &lt;cmd_seq&gt; 'endif'
  | 'while' &lt;expr&gt; 'do' &lt;cmd_seq&gt; 'endwhile'
  | &lt;ide&gt; ':=' &lt;rhs&gt;
  | &lt;ide&gt; '[' &lt;expr&gt; ']' ':=' &lt;expr&gt;
  | '*' &lt;expr&gt; ':=' &lt;expr&gt;

&lt;rhs&gt; ::=
    '*' &lt;expr&gt;
  | &lt;ide&gt;
  | '[' &lt;expr&gt; ']'
  | 'protect' '(' &lt;rhs&gt; ')'
  | &lt;expr&gt;

&lt;expr&gt; :=
    'true' | 'false'
  | &lt;int&gt;
  | &lt;ide&gt;
  | 'length' '(' &lt;expr&gt; ')'
  | 'base' '(' &lt;expr&gt; ')'
  | &lt;expr&gt; '+' &lt;expr&gt;
  | &lt;expr&gt; '&lt;' &lt;expr&gt;
  | &lt;expr&gt; '?' &lt;expr&gt; ':' &lt;expr&gt;
  | '(' &lt;expr&gt; ')'
  </pre>
  </details>
  <button id="btn">Parse</button>
  <div id="output">

  </div>

  <script>
    const genAlphaNodes = document.getElementById("gen-alpha")
    const genFullDefUse = document.getElementById("gen-defuse")

    /**
     * @callback genNewNameCallback
     * @returns {String} A fresh name
     */

    /**
     * Analyzes an expression
     * @param expr The expression to analyze
     * @param {Set<String>} edgeSet Where new edges will be put
     * @param {Set<String>} nameSet Where new names will be put
     * @param {genNewNameCallback} getNewName Generates fresh names
     * @returns A tuple containing the name of the expression and its string representation
     */
    function getExpressionConstraints(expr, edgeSet, nameSet, getNewName) {
      switch(expr.type) {
        case "int":
        case "bool":
          return [ expr.value.toString(), expr.value.toString() ]
        case "name":
          if(genAlphaNodes.checked) { edgeSet.add(`${expr.name} -> alpha_${expr.name}`) }
          nameSet.add(`${expr.name} [style=filled]`)
          return [ expr.name, expr.name ]
        case "length":
        case "base":
          {
            const newName = getNewName()

            const e = getExpressionConstraints(expr.value, edgeSet, nameSet, getNewName)
            edgeSet.add(`${e[0]} -> ${newName}`)
            nameSet.add(`${newName} [label="${expr.type}(${e[1]})"]`)

            return [ newName, `${expr.type}(${e[1]})` ]
          }
        case "select":
          {
            const newName = getNewName()

            const e1 = getExpressionConstraints(expr.e1, edgeSet, nameSet, getNewName);
            const e2 = getExpressionConstraints(expr.e2, edgeSet, nameSet, getNewName);
            const e3 = getExpressionConstraints(expr.e3, edgeSet, nameSet, getNewName);

            edgeSet.add(`${e1[0]} -> ${newName}`)
            if(genFullDefUse.checked) {
              edgeSet.add(`${e2[0]} -> ${newName}`)
              edgeSet.add(`${e3[0]} -> ${newName}`)
            }
            nameSet.add(`${newName} [label="${e1[1]} ? ${e2[1]} : ${e3[1]}"]`)
            return [ newName, `${e1[1]} ? ${e2[1]} : ${e3[1]}` ]
          }
        case "op":
          {
            const newName = getNewName();

            const e1 = getExpressionConstraints(expr.e1, edgeSet, nameSet, getNewName);
            const e2 = getExpressionConstraints(expr.e2, edgeSet, nameSet, getNewName);
            
            edgeSet.add(`${e1[0]} -> ${newName}`)
            edgeSet.add(`${e2[0]} -> ${newName}`)
            nameSet.add(`${newName} [label="${e1[1]} ${expr.op} ${e2[1]}"]`)
            return [ newName, `${e1[1]} ${expr.op} ${e2[1]}` ]
          }
        default: throw "Not implemented"
      }
    }

    function getRhsConstraints(rhs, edgeSet, nameSet, getNewName) {
      switch(rhs.type) {
        case "expr": {
          return getExpressionConstraints(rhs.expr, edgeSet, nameSet, getNewName);
        }
        case "arr-read": {
          const e = getExpressionConstraints(rhs.index, edgeSet, nameSet, getNewName)
          const newName = getNewName()
          nameSet.add(`${newName} [label="${rhs.arr}[${e[1]}]"]`)
          edgeSet.add(`${e[0]} -> _S_`)
          edgeSet.add(`_T_ -> ${newName}`)
          if(genFullDefUse.checked) {
            edgeSet.add(`${e[0]} -> ${newName}`)
          }
          return [newName, `${rhs.arr}[${e[1]}]`]
        }
        case "ptr-read": {
          const e = getExpressionConstraints(rhs.expr, edgeSet, nameSet, getNewName)
          const newName = getNewName()

          nameSet.add(`${newName} [label="*${e[1]}"]`)
          edgeSet.add(`${e[0]} -> _S_`)
          edgeSet.add(`_T_ -> ${e[0]}`)

          if(genFullDefUse.checked) {
            edgeSet.add(`${newName} -> ${e[0]}`)
          }

          return [newName, `*${e[1]}`]
        }
        case "protect": {
          const r = getRhsConstraints(rhs.arg, edgeSet, nameSet, getNewName)
          const newName = getNewName()
          nameSet.add(`${newName} [label="protect(${r[1]})"]`)

          if(genFullDefUse.checked) {
            edgeSet.add(`${newName} -> ${r[0]}`)
          }

          return [newName, `protect(${r[1]})`]
        }
      }
    }

    /**
     * Analyzes a command
     * @param expr The command to analyze
     * @param {Set<String>} edgeSet Where new expression edges will be put
     * @param {Set<String>} nameSet Where new expression names will be put
     * @param {genNewNameCallback} getNewName Generates fresh expression names
     */
    function getCommandConstraints(cmd, edgeSet, nameSet, getNewName) {
      switch(cmd.type) {
        case "skip":
        case "fail": break;
        case "seq": {
          getCommandConstraints(cmd.c1, edgeSet, nameSet, getNewName)
          getCommandConstraints(cmd.c2, edgeSet, nameSet, getNewName)
          break;
        }
        case "if": {
          const cond = getExpressionConstraints(cmd.cond, edgeSet, nameSet, getNewName)
          getCommandConstraints(cmd.c1, edgeSet, nameSet, getNewName)
          getCommandConstraints(cmd.c2, edgeSet, nameSet, getNewName)

          edgeSet.add(`${cond[0]} -> _S_`);
          break;
        }
        case "while": {
          const cond = getExpressionConstraints(cmd.cond, edgeSet, nameSet, getNewName)
          getCommandConstraints(cmd.body, edgeSet, nameSet, getNewName)

          edgeSet.add(`${cond[0]} -> _S_`);
          break;
        }
        case "asgn": {
          const r = getRhsConstraints(cmd.value, edgeSet, nameSet, getNewName)
          edgeSet.add(`${r[0]} -> ${cmd.name}`)
          break;
        }
        case "arr-write": {
          const e1 = getExpressionConstraints(cmd.index, edgeSet, nameSet, getNewName)
          const e2 = getExpressionConstraints(cmd.expr, edgeSet, nameSet, getNewName)
          edgeSet.add(`${e1[0]} -> _S_`)
          break;
        }
        case "ptr-write": {
          const e1 = getExpressionConstraints(cmd.ptr, edgeSet, nameSet, getNewName)
          const e2 = getExpressionConstraints(cmd.expr, edgeSet, nameSet, getNewName)
          edgeSet.add(`${e1[0]} -> _S_`)
          break;
        }
        default: throw `Not implemented: ${cmd.type}`
      }
    }

    function getDigraph(edgeSet, nameSet) {
      return `digraph {
        _T_ [label="T" shape=circle fontsize=20 fontcolor="#fc369d" color="#fc369d"]
        _S_ [label="S" shape=circle fontsize=20 fontcolor="#1cbec2" color="#1cbec2"]
        ${[...nameSet.values()].join("\n")}

        ${[...edgeSet.values()].join("\n")}
      }`
    }

    const input = document.getElementById("input")
    const output = document.getElementById("output")
    const btn = document.getElementById("btn")

    btn.addEventListener('click', function() {
      try {
        let i = 0;
        const edgeSet = new Set();
        const nameSet = new Set();
        const cmd = parser.parse(input.value.trim())
        getCommandConstraints(cmd, edgeSet, nameSet, () => `e_${i++}`)
        const svg = Viz(getDigraph(edgeSet, nameSet), "svg")
        output.innerHTML = svg;
      } catch(e) {
        output.innerText = e.toString()
        console.log(e)
      }
    })
  </script>
</body>
</html>